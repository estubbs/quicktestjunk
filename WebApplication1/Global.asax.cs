using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Http;
using System.Web.Mvc;
using System.Web.Optimization;
using System.Web.Routing;
using Serilog.Events;
using System.Collections.Specialized;
using Serilog.Filters;

namespace WebApplication1
{

    public class RequeUriEnricher : ILogEventEnricher
    {
        public void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory)
        {
            var context = HttpContext.Current;
            if (context == null)
                return;

            var request = context.Request;
            var response = context.Response;

            if (request != null)
            {
                _EnrichRequest(request, logEvent, propertyFactory);
            }
            if (response != null)
            {
                _EnrichResponse(response, logEvent, propertyFactory);
            }
        }
        void _EnrichResponse(HttpResponse httpResponse, LogEvent logEvent, ILogEventPropertyFactory propertyFactory)
        {
            var headers = transformHeaders(httpResponse.Headers);
            logEvent.AddOrUpdateProperty(propertyFactory.CreateProperty("ResponseHeaders", headers));
            logEvent.AddOrUpdateProperty(propertyFactory.CreateProperty("ResponseStatusCode", httpResponse.StatusCode));
        }
        private void _EnrichRequest(HttpRequest request, LogEvent logEvent, ILogEventPropertyFactory propertyFactory)
        {
            var method = request.HttpMethod;
            var isSecure = request.IsSecureConnection;
            var ipAddress = request.UserHostAddress;
            var uri = request.Url;

            var headers = request.Headers;
            Dictionary<string, string[]> allHeaders = transformHeaders(headers);
            var obj = new
            {
                Host = headers.Get("Host"),
                Accept=headers.Get("Accept"),
                UserAgent=headers.Get("User-Agent")

            };

            logEvent.AddOrUpdateProperty(propertyFactory.CreateProperty("HttpMethod", method));
            logEvent.AddOrUpdateProperty(propertyFactory.CreateProperty("IsHttps", isSecure));
            logEvent.AddOrUpdateProperty(propertyFactory.CreateProperty("ClientIpAddress", ipAddress));
            logEvent.AddOrUpdateProperty(propertyFactory.CreateProperty("RequestHeaders3", obj,true));
            logEvent.AddOrUpdateProperty(propertyFactory.CreateProperty("RequestUri", uri));
            

        }

        private static Dictionary<string, string[]> transformHeaders(NameValueCollection headers)
        {
            Dictionary<string, string[]> allHeaders = new Dictionary<string, string[]>(headers.Count);

            for (var i = 0; i < headers.Count; i++)
            {
                var headerValues = headers.GetValues(i);
                var key = headers.GetKey(i);
                allHeaders.Add(key, headerValues);
            }

            return allHeaders;
        }
    }

    public class ILogModule : IHttpModule
    {
        private static ILogger logger;


        public void Dispose()
        {

        }
        public void Init(HttpApplication context)
        {
            logger = Serilog.Log.ForContext<ILogModule>();
            //context.Error += Context_Error;
            context.LogRequest += Context_LogRequest;
        }

        private void Context_Error(object sender, EventArgs e)
        {
            
            /* this should only fire for truly unhandeled exceptions that are generated by the framework
             * MVC controllers and Web Api controllers will usually end up being the source of the log instead
             * of this event
             */

            var app = sender as HttpApplication;
            var exception = app.Context.Server.GetLastError();
            var httpException = exception as HttpException;

            /* if customErrors are on, this will log the unhandled exception and also clear the errors from the context
             * this is so that the yellow screen error message handler doesn't get in the way even though we turned it on.
             * The intent is to use the iis based system.webserver httpErrors element to set the error page for these types
             * of unhandled errors.
             */

            if (app.Context.IsCustomErrorEnabled) // if off, or remoteonly, we want to still see the yellow error page
            {
                app.Server.ClearError(); // avoid yellow error page                

                if (httpException != null)
                {
                    var statusCode = httpException.GetHttpCode();
                    app.Response.StatusCode = statusCode;
                    if (statusCode >= 500)
                    {
                        logger.Error(httpException, httpException.Message);
                    }
                    else
                    {
                        logger.Warning(httpException, httpException.Message);
                    }
                }
                else if (exception != null)
                {
                    app.Response.StatusCode = 500;
                    logger.Error(exception, "{ResponseStatusCode} - " + exception.Message, 500);
                }
            }
        }
        private void Context_LogRequest(object sender, EventArgs e)
        {
            var app = sender as HttpApplication;
            var context = app.Context;

            if (context.Response.StatusCode >= 500)
            {
                logger.Error(context.Response.Status);
            }
            else if (context.Response.StatusCode >= 400)
            {
                logger.Warning(context.Response.Status);
            }
            else
            {
                logger.Information("Response completed successfully");
            }

        }
    }
    public class MvcApplication : System.Web.HttpApplication
    {
        protected void Application_Start()
        {
            Log.Logger = new Serilog.LoggerConfiguration()
                .Enrich.FromLogContext()
                .WriteTo.Trace(new Serilog.Formatting.Json.JsonFormatter())
                .WriteTo.File(new Serilog.Formatting.Json.JsonFormatter(), "c:\\logs\\log.json")
                .WriteTo.Logger(cfg =>
                        cfg
                        .Filter.ByIncludingOnly(Matching.FromSource<ILogModule>())
                        .Enrich.With<RequeUriEnricher>()
                        .WriteTo.Elasticsearch(new Serilog.Sinks.Elasticsearch.ElasticsearchSinkOptions(new Uri("http://localhost:9200/")) { AutoRegisterTemplate = true, IndexFormat = "logstash3-{0:yyyy.MM.dd}", InlineFields = true, OverwriteTemplate = true, TypeName = "logevent2" })
                   )
                .CreateLogger();



            AreaRegistration.RegisterAllAreas();
            GlobalConfiguration.Configure(WebApiConfig.Register);
            FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
            RouteConfig.RegisterRoutes(RouteTable.Routes);
            BundleConfig.RegisterBundles(BundleTable.Bundles);
        }

    }
}
